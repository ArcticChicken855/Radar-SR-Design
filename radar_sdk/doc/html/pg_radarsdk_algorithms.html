<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RFS SDK Documentation: Algorithms supported by Radar SDK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ifx_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RFS SDK Documentation
   </div>
   <div id="projectbrief">Infineon RFS SDK for evaluation and development of applications with Infineon XENSIV 60GHz radar sensors, PAS CO2 sensors, and Multigas sensors.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('pg_radarsdk_algorithms.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Algorithms supported by Radar SDK </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="ssct_radarsdk_algorithms_mti"></a>
Moving Target Indicator</h1>
<p>The Moving Target Indicator (MTI) is a radar targeting method that helps to discriminate moving targets from static targets and clutter.</p>
<p>The MTI filter is basically a first order IIR (Infinite Impulse Response) filter. It is typically used on a range spectrum to filter out stationary targets. Thus, the name "Moving Target Indication" filtering. The effect of static target removal with the MTI filter can be seen when applied on the range spectrums from successive FMCW frames. The handle stores a historical component of range spectrums which have information of static targets in previous spectrums. This historical component is subtracted from the range spectrum of the next incoming FMCW frame.</p>
<p>The filter coefficient \(\alpha\) needs to be specified when creating an instance of the MTI module.</p>
<p>The MTI filtering is realized according to the following recurrence formulae ( \(n=0,1,2,\dots\)): </p><p class="formulaDsp">
\[ \mathrm{RSF}_n = \mathrm{RS}_n - \mathrm{RSH}_{n-1} \\ \mathrm{RSH}_n = \alpha \mathrm{RS}_n + (1 - \alpha) \mathrm{RSH}_{n-1} \]
</p>
<p>with \(\mathrm{RSH}_{-1}=0\) and where:</p><ul>
<li>\(\mathrm{RS}_n\) = \(n\)-th input vector</li>
<li>\(\mathrm{RSF}_n\) = \(n\)-th MTI filtered output vector</li>
<li>\(\mathrm{RSH}_n\) = Historical component after filtering the \(n\)-th input vector</li>
<li>\(\alpha\) = Filter-coefficient of the IIR filter</li>
</ul>
<p>Programming details are available at the <a class="el" href="group__gr__mti.html">Moving Target Indicator (MTI)</a> algorithm API.</p>
<hr  />
 <h1><a class="anchor" id="ssct_radarsdk_algorithms_2dmti"></a>
2D Moving Target Indicator</h1>
<p>The Moving Target Indicator (MTI) is a radar targeting method that helps to discriminate moving targets from static targets and clutter. Different algorithms exist for MTIs using e.g. the doppler frequency shift or evaluating the continuous phase deviations of the reflected signals to discriminate moving targets from static ones. The algorithm implemented here operates on a 2D range-doppler map represented as a matrix \(D\) and subtracts a certain amount \(\alpha\) of its time average \(D_\mathrm{avg}\) to rule out static targets as they don't change on the map from the average to a single instance. The resulting matrix \(D_\mathrm{MTI}\) is the doppler map with the MTI applied: </p><p class="formulaDsp">
\[ D_\mathrm{MTI} = D-\alpha D_\mathrm{avg} \]
</p>
<p>Figure 1 shows an example of a range-doppler map as it is computed directly from the raw data. The detected signal's strength is represented by different colors. The color map depicts strong signal areas in orange and red, while areas without objects are marked blue. It can be seen that there is clutter and atmospheric noise in the blue and dark blue areas, as well as strong static values around the origin and along the horizontal and vertical axes. This indicates low rumble and windowing artefacts. A target present at around 0.55 m hardly sticks out from the artefacts without an MTI applied.</p>
<div class="image">
<img src="img_range_doppler_map_without_mti.png" alt="" width="600px"/>
<div class="caption">
Figure 1. Range-doppler map without MTI for a target present at 0.55 m with a speed of -4 m/s</div></div>
<p>Figure 2 shows the same range-doppler map after applying the MTI and a threshold based removal of low energy atmospheric noise. All static components are gone, only leaving clearly present the moving target at 0.55 m with a detected speed of -4 m/s meaning that it approaches the radar system with 4 m/s. With the resulting range-doppler map further processing and detection can easily be performed.</p>
<div class="image">
<img src="img_range_doppler_map_with_mti.png" alt="" width="600px"/>
<div class="caption">
Figure 2. Range-doppler map with an MTI applied for a target present at 0.55 m with a speed of -4 m/s</div></div>
<p>Programming details are available at the <a class="el" href="group__gr__mti2d.html">Moving Target Indicator 2D (2DMTI)</a> algorithm API.</p>
<hr  />
 <h1><a class="anchor" id="ssct_radarsdk_algorithms_rdm"></a>
Range-Doppler Map</h1>
<p>The range-doppler map is a 2D representation showing the ranges and velocities of detected objects relative to the radar system. The map's structure is a 2D grid with the range being represented on the ordinate and the velocity being represented on the abscissa as shown by Figure 1. The map's origin is usually located on the bottom side in the middle, as there can be no negative values for the range but equally positive and negative values for the velocity. Positive velocity values indicate, that the object is heading away from the radar system, while negative velocity values indicate that the object is approaching the radar system. The detected objects are represented by different colors of a color map according to their strengths. The color map depicts strong signal areas in orange and red, while areas without objects are marked blue.</p>
<div class="image">
<img src="img_range_velocity_estimation.png" alt="" width="600px"/>
<div class="caption">
Figure 1. Range and velocity estimation for a target present at 0.25 m with a speed of 2 m/s</div></div>
<p>For detecting not only the range of objects but also their velocity relative to a radar system, a frame of consecutive chirps needs to be sent out towards the object. As the range of a moving object changes linearly over time, the small range differences \(\Delta R\) from one chirp to the next during the time period \(T_\mathrm{I}\) can be used to determine the object's velocity \(v\) by: </p><p class="formulaDsp">
\[ v = \frac{\Delta R}{T_\mathrm{I}} \]
</p>
<p>As the range differences \(\Delta R\) are usually very small, detecting the change of the IF signal's frequency \(f_\mathrm{IF}\) needs to be accurate in a way that is beyond the signal processing's precision in practical radar systems, which are usually based on FFT methods. The frequency \(\Delta f\) resulting from the range differences \(\Delta R\) from chirp to chirp usually fall within one FFT bin and thus can't be detected as frequency changes directly.</p>
<p>Nevertheless, as the phase \(\varphi_\mathrm{IF}\) of the IF signal is also proportional to the range \(R\) and much more sensitive of small changes, the velocity \(v\) can be derived from the IF signal's phase \(\Delta \varphi_\mathrm{IF}\) change from one chirp to the next over time period \(T_\mathrm{I}\) </p><p class="formulaDsp">
\[ v = \frac{\lambda}{4 \pi T_\mathrm{I}} \Delta \varphi_\mathrm{IF} \]
</p>
<p>The underlying data structure used for representing a range-doppler map is a 2D matrix which is spanning a grid. The first dimension represents certain range values, while the second dimension represents certain velocity values. Thus, a range-angle matrix is always a discrete representation, only evaluating predefined range/velocity pairs. The strength of the radar signal, i.e. the presence of objects at the specific point, is represented by the different matrix entries themselves.</p>
<p>A range-doppler matrix can be extended in the third dimension to contain information for different aspects. These are usually either different antennas or different predefined angles, thus combining the range-doppler matrix with a range-angle matrix.</p>
<p>Programming details are available at the <a class="el" href="group__gr__rdm.html">Range Doppler Map</a> algorithm API.</p>
<hr  />
 <h1><a class="anchor" id="ssct_radarsdk_algorithms_rai"></a>
Range-Angle Image</h1>
<p>The range-angle image is a 2D representation of a plane in the field of view of a radar system. It shows the ranges and angles of detected objects relative to the radar system. The map is set up as a 2D grid where the range is represented on the ordinate while the angle is represented on the abscissa, as can be seen in Figure 1. The origin is usually located on the bottom side in the middle, as there can be no negative values for the range but equally positive and negative values for the angle, with an angle of 0 being broadside. Detected objects are represented by different colors of a color map according to their strengths. The color map depicts strong signal areas in orange and red, while areas without objects are marked blue.</p>
<div class="image">
<img src="img_range_angle_estimation.png" alt="" width="600px"/>
<div class="caption">
Figure 1. Range and angle estimation for a target present at 0.75 m with an angle of -5&deg;</div></div>
<p>For detecting not only the range of objects but also their angle relative to a radar system, the antennas need to be set up as a Uniform Linear Array (ULA). Each direction of detection needs a ULA of at least two antennas positioned in its plane. Thus, the minimum requirement for detecting azimuth and elevation is a ULA with three antennas in an L shape.</p>
<p>The underlying data structure for a range-angle map is a 2D matrix spanning a grid. The first dimension represents certain range values, while the second dimension represents certain angle values. Thus, a range-angle matrix is per se a discrete representation, only evaluating certain points in space. The strength of the radar signal, i.e. the presence of objects at the specific point, is represented by the different matrix entries themselves.</p>
<p>A range-angle matrix can be extended in the third dimension to contain information for different aspects. These can be different dimensions in space but also different versions of beam patterns, e.g. if they are weighted by a certain weighting function.</p>
<p>Programming details are available at the <a class="el" href="group__gr__rai.html">Range Angle Image</a> algorithm API.</p>
<hr  />
 <h1><a class="anchor" id="ssct_radarsdk_algorithms_dbf"></a>
Digital Beam Former (DBF)</h1>
<p>The Digital Beamforming (DBF) is a method to focus a radar transmitter or receiver in a certain direction in 3D space. In this context, the left to right direction is commonly referred to as azimuth and the high to low direction as elevation. The antennas of DBF systems are set up as a Uniform Linear Array (ULA) while each direction needs a ULA of at least two antennas positioned in its plane to perform beamforming. Thus, the minimum requirement for detecting azimuth and elevation is a ULA with three antennas in an L shape.</p>
<p>Figure 1. shows a planar wave reaching a ULA with an Angle of Arrival (AoA) \(\Theta\). The antennas are spaced by the distance \(d\). It can be seen that the upper receivers are reached first, resulting in a phase shift between the different antenna signals. In beamforming, the different antennas of the ULA are weighted individually in their phase and amplitude, shown in Figure 1. by \(W_\mathrm{x}\) and summed up at the end. In this active mathematic weighting process, beamforming differs from other analytic algorithms for Angle of Arrival (AoA) detection, as it can be compared to applying a windowing function in 3D space.</p>
<div class="image">
<img src="img_planar_wave_beamforming.png" alt="" width="600px"/>
<div class="caption">
Figure 1. A planar wave arriving at a ULA with subsequent beamforming</div></div>
<p>For each specific direction of the beam, the applied weights and phase shifts differ so that all other directions are actively set close to zero. Thus, only when the signals of all ULA antennas are shifted in-phase and eventually weighted by 100% the maximum sum over all signals can be generated. Although Figure 1. shows a receiver ULA, beamforming can be applied with the same theory for both receive and transmit signals.</p>
<p>In DBF all ULA's antenna signals are sampled and therefore present for processing at the same time. Thus, DBF allows for a precise and simultaneous processing of different angles and frequencies, only limited by the computational effort, but theoretically with arbitrary precision. The theory and implementation of DBF algorithms as described here can not only be used to analyze and weight signals in 3D space, but also for FFT processed spectral representations or derived properties like range-doppler maps.</p>
<p>The weighting and shifting of each antenna signal grouped in matrix \(A\) as column vectors is usually provided and implemented in matrix form, with \(\w\) being a row vector containing the individual weights for each antenna signal by: </p><p class="formulaDsp">
\[ r = A w \]
</p>
<p>This results in a sum vector \(r\) which is referred to as conventional beamforming and is visualized in Figure 2. More sophisticated methods for DBF like Capon and MUSIC are also available, but despite the higher computational effort, they do not always perform better than conventional beamforming.</p>
<div class="image">
<img src="img_beamforming_theory_with_ula.png" alt="" width="600px"/>
<div class="caption">
Figure 2. The theory of beamforming visualized with a ULA for elevation</div></div>
<p>Programming details are available at the <a class="el" href="group__gr__dbf.html">DBF</a> algorithm API.</p>
<hr  />
 <h1><a class="anchor" id="ssct_radarsdk_algorithms_detect_oscfar"></a>
Ordered Statistics Constant False Alarm Rate (OS-CFAR)</h1>
<p>The major challenge in object detection is to decide if a peak in the spectrum corresponds to a potential object or not. Comparing the frequency spectrum to a fixed threshold value may cause many of wrong object detections. Thus, so-called constant false alarm rate (CFAR) algorithm is used, which is able to calculate an adaptive threshold value due to the estimated noise floor.</p>
<p>The Ordered Statistics Constant False Alarm Rate (OS-CFAR) is designed to suppress target masking. The OS-CFAR rank orders the N samples in the CFAR reference window and selects the k-th sample as the CFAR statistic. The CFAR is thus capable of rejecting \(N - k\) interfering targets.</p>
<p>From a CFAR loss perspective, the detection performance may be achieved in a homogenous interference environment using an OS-CFAR with \(N\) = 24.</p>
<p>An OS-CFAR may also be used to address self-target masking. It eliminates the need for guard cells (i.e., \(NG\) = 0) provided the total number of reference cells containing target returns is less than \(N - k\).</p>
<p>For OS-CFAR a simple expression relates the CFAR constants associated with a linear and square law detector. The two OS-CFAR constants are related via: </p><p class="formulaDsp">
\[ \alpha_\mathrm{OS_{linear}} = \sqrt{\alpha_\mathrm{OS_{squarelaw}}} \]
</p>
<p>Figure 1. gives the output after the OS-CFAR implementation on the range-angle map. It can be seen that there are two regions of detections obtained after OS-CFAR.</p>
<div class="image">
<img src="img_oscfar.png" alt="" width="800px"/>
<div class="caption">
Figure 1. Output after the OS-CFAR implementation on the range-angle map</div></div>
<p>Programming details are available at the <a class="el" href="group__gr__oscfar.html">OS-CFAR</a> algorithm API.</p>
<hr  />
 <h1><a class="anchor" id="ssct_radarsdk_algorithms_detect_dbscan"></a>
Density-Based Spatial Clustering of Applications with Noise (DBSCAN)</h1>
<p>The Density-Based Spatial Clustering of Applications with Noise (DBSCAN) is a data density-based clustering non-parametric algorithm: given a set of points in some space, it groups together points that are closely packed together (points with many nearby neighbors), marking as outliers points that lie alone in low-density regions (whose nearest neighbors are too far away).</p>
<p>DBSCAN requires two parameters:</p><ul>
<li>\(\varepsilon\) (Eps) : Largest radius of neighborhood around a point.</li>
<li><em> MinPts </em>: Minimum number of points in an \(\varepsilon\)-neighborhood of that point.</li>
</ul>
<p>It starts with an arbitrary starting point that has not been visited. This point's \(\varepsilon\)-neighborhood is retrieved, and if it contains sufficiently many points, a cluster is started. Otherwise, the point is labeled as noise. Note that this point might later be found in a sufficiently sized \(\varepsilon\)-environment of a different point, and hence be made part of a cluster.</p>
<p>If a point is found to be a dense part of a cluster, its \(\varepsilon\)-neighborhood is also part of that cluster. Hence, all points that are found within the \(\varepsilon\)-neighborhood are added, as is their own \(\varepsilon\)-neighborhood when they are also dense.</p>
<p>This process continues until the density-connected cluster is completely found. Then, a new unvisited point is retrieved and processed, leading to the discovery of a further cluster or noise.</p>
<div class="image">
<img src="img_dbscan.png" alt="" width="800px"/>
<div class="caption">
Figure 1. Output of the clustering algorithm DBSCAN</div></div>
<p>The detections obtained after <a class="el" href="pg_radarsdk_algorithms.html#ssct_radarsdk_algorithms_detect_oscfar">OS-CFAR</a> are fed into the DBSCAN clustering algorithm, which finds the point clouds which could correspond to the target and discards point clouds which could be coming from noise.</p>
<p>Programming details are available at the <a class="el" href="group__gr__dbscan.html">DBSCAN</a> algorithm API.</p>
<hr  />
 <h1><a class="anchor" id="ssct_radarsdk_algorithms_detect_capon"></a>
Capon</h1>
<p>The Capon algorithm is a conventional spectral-based method which is used to improve resolution of Bartlett Algorithm, and is referred to as the Minimum Variance Distortionless Response (MVDR) beamformer. The main idea of Capon algorithms to minimize the received power of the incoming signal in all direction while maintaining a unity gain in look direction.</p>
<p>The matrix processor is referred to as the MVDR beamformer and was first derived by Capon, is given as: </p><p class="formulaDsp">
\[ \Lambda (w : k_s) = [v^H (w : k_s) S^{-1}_n(w) v(w : k_s)]^{-1} \]
</p>
<p>For notational simplicity, it is convenient to suppress \(w\) and \(k\), in this formula, where the subscript emphasizes the optimization criterion. </p><p class="formulaDsp">
\[ w^H_{mvdr} = \Lambda_s v^H S^{-1}_n \]
</p>
<ul>
<li>\(v\): Antenna steering vector. It calculates the theoretical signal phase for every antenna and every possible direction of arrival of signal. Thus, it computes values of signal at a grid of all theta where theta, is the possible directions of arrival of signals.</li>
<li>\(w\): Weights computed to optimize the signal power through Capon</li>
<li>\( S = E{x(t) x^T(t)} \): Covariance matrix obtained from the received signal \(x(t)\).</li>
</ul>
<p>Programming details are available at the <a class="el" href="group__gr__anglecapon.html">Angle Capon</a> algorithm API.</p>
<hr  />
 <h1><a class="anchor" id="ssct_radarsdk_algorithms_segmentation"></a>
Segmentation</h1>
<p>The Segmentation algorithm allows splitting the sensor field of view into up to 6 segments, in each of which an active target can be detected.</p>
<p>Programming details are available at the <a class="el" href="group__gr__segmentation.html">Segmentation and Seamless Tracking</a> algorithm API.</p>
<hr  />
 <h1><a class="anchor" id="ssct_radarsdk_algorithms_presencesensing"></a>
Presence Sensing</h1>
<p>The Presence Sensing algorithm allows determining whether or not an object is present.</p>
<p>Programming details are available at the <a class="el" href="group__gr__cat___radar_presence.html">Radar Presence (ifxRadarPresenceSensing)</a> algorithm API. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Sep 13 2023 18:41:37 for RFS SDK Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
