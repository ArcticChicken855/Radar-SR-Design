# Python wrapper developer guidelines

## Prerequisites

Before starting, make sure that you've set a clean development (virtual) environment
using Python [venv](https://docs.python.org/3/library/venv.html), executing following command:

```bash
python -m venv .venv
```

The virtual environment shall be enabled before proceeding with development of the
actual Python wrapper, which can be achieved using the following command, on Windows:

```bash
.venv/Scripts/activate
```

or using the following command on Linux:

```bash
source .venv/bin/activate
```

> **Warning**: usage of system level Python is discouraged, as it can quite easily lead to
"it worked on my system" kind of issues. Virtual environment ensures usage of "clean"
environment, which shall contain only dependencies required by the Python wrapper
(that can later on get pinned, exported and shared with others).

## Coding style

When in doubt, please consult a well defined [PEP-8](https://pep8.org/#pep-8-%E2%80%94-the-style-guide-for-python-code),
which provides style guidelines, helping you to write a better ("Pythonic") code.

In addition, it is highly recommended to "enforce" the widely accepted code style
(defined in `PEP-8`) using one of the linters, such as [ruff](https://github.com/astral-sh/ruff).
You may even consider using [black](https://github.com/psf/black), which will automatically
format your code, without compromises.

### Import of sub-modules

Usage of wild-card imports (`from M import *`) may be tempting, as it "simplifies"
the usage of developed modules, but it turns out to be an error-prone approach which
prevents linters (and yourself) from spotting the usage of modules/interfaces that
are not imported, and leads to a bad code design in general (as your code can suddenly
start importing each and every module and their attributes, even for an import of simple
common helper function).

Let's try to use explicit imports instead, as this will give us an easier understanding
on which interfaces are being consumed by each of the sub-modules, making debugging and
testing a lot easier.

In case that usage of wild-card imports is absolutely necessary, one shall use `__all__`
mechanism to narrow the scope of the imported attributes.

Interfaces that are designed to be directly, commonly, used by the end-users, may
be imported through `__init__.py` files in each of the packages, which will shorten the
required import syntax.

For example: instead of using `from ifxradarsdk.ltr11.ltr11 import DeviceLtr11` we may
place `from .ltr11 import DeviceLtr11` in `__init__.py` of `ltr11` package, which will
enable the end-user to import it as following: `from ifxradarsdk.ltr11 import DeviceLtr11`.

## Tooling

[Visual Studio Code](https://code.visualstudio.com/) is recommended as a code editor
which fits most of the Python wrapper development use cases. It is free, open source
editor, with many helpful extensions and big community feeding answers on the common
questions.
On Windows, you can simply install it through [scoop](https://scoop.sh/), using:

```bash
scoop install vscode
```

[Python extension](https://code.visualstudio.com/docs/languages/python) is the single
requirement for developing Python code. Once installed, it provides you with auto-detection
of Python interpreters (including the ones created through `venv`), built-in debugging
capabilities and support for various linters, that would help you write a well-styled
Python code.

## Python wrapper structure

Python wrapper is designed as a single Python wheel which provides different
functionality through its sub-modules (such as `ltr11`, `mimose`, etc.).

Complete functionality is contained under `src/ifxradarsdk` directory.

The wheel's metadata is defined in `pyproject.toml.in` under distribution package's
root directory.
As CMake provides the "knowledge" on current version, dependencies, etc. this file acts
as a template, that gets converted into the final `pyproject.toml` by CMake
(during the build).

The Python modules are split into several sub-directories, for better overview of existent,
and easier development of further, functionality.

All of the common functionality (such as common types, exceptions, etc.), that are used
by several sub-modules, shall be kept under the package named `common`, from where it
gets imported and used by the sub-modules.

The sub-modules (such as `ltr11`, `mimose`, etc.) shall be contained as part of a separate
sub-directory, named according to the module name.

Python wrappers are wrapping functionality provided by shared libraries, meaning that
they are also required as part of the Python wheel, to enable its proper usage.
The required shared libraries (for the specific platform) are generated by CMake
(during build) under `src/ifxradarsdk/lib` directory.

## Workflow

1. Create and activate Python virtual environment (described in the prerequisite section
of this document)
2. Install `ifxradarsdk` in editable mode:

    ```bash
    python -m pip install --editable path/to/directory/containing/pyproject.toml
    ```

    This will "mimic" the installation of the project as actual wheel, allowing you
    to develop and immediately test functionality on the same way as its intended to be
    used (through installation of the wheel and import of the package -> no manual
    copy-pasting of the files).
    Once installed, you don't have to re-install it (unless `pyproject.toml` gets changed),
    since all the changes done to Python modules will automatically get reflected in
    your current Python virtual environment.

    Hint: in case that any functionality of the actual sources (shared libraries) gets
    modified, re-build (through CMake) is required. This will re-generate the `lib`
    directory, together with all of the contained shared libraries. Re-build of sources
    doesn't require re-installation of Python wheel in editable mode, unless changes
    are causing `pyproject.toml` to be modified.
3. Happy developing and testing of your Python wrapper.
