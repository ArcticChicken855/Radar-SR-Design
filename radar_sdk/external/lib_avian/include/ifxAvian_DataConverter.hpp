/**
 * \file ifxAvian_DataConverter.hpp
 *
 * This file declares a class that converts packed raw data format generated by
 * Avian devices into a different target data format.
 */
/* ===========================================================================
** Copyright (C) 2020-2023 Infineon Technologies AG
**
** Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are met:
**
** 1. Redistributions of source code must retain the above copyright notice,
**    this list of conditions and the following disclaimer.
** 2. Redistributions in binary form must reproduce the above copyright
**    notice, this list of conditions and the following disclaimer in the
**    documentation and/or other materials provided with the distribution.
** 3. Neither the name of the copyright holder nor the names of its
**    contributors may be used to endorse or promote products derived from
**    this software without specific prior written permission.
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
** AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
** ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
** LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
** INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
** CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
** ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
** POSSIBILITY OF SUCH DAMAGE.
** ===========================================================================
*/

#ifndef IFX_AVIAN_DATACONVERTER_H
#define IFX_AVIAN_DATACONVERTER_H

// ---------------------------------------------------------------------------- includes
#include "ifxAvian_IPort.hpp"

// ---------------------------------------------------------------------------- namespaces
namespace Infineon {
namespace Avian {

// ---------------------------------------------------------------------------- DataConverter
/**
 * \brief This class converts packed raw data received from an Avian device into
 *        a different data format.
 *
 * This class takes a reference to an \ref HW::IReadPort that returns packed raw
 * data. On the other hand this class itself implements \ref HW::IReadPort for a
 * different data type, so an application can use a DataConverter instance
 * instead of the source Avian port.
 *
 * The data converter processes the data in-place. The target buffer provided
 * by the application is forwarded to the source reader, so first the packed
 * raw data is put into the application's buffer, then the data is converted.
 * Due to this in-place processing, it is not allowed to use a target data
 * format of a smaller size than the packed data.
 *
 * \param DATA_TYPE  The target data format, packed raw data is converted to.
 */
template <typename DATA_TYPE>
class DataConverter : public HW::IReadPort<DATA_TYPE>
{
public:
    /*
     * Due to in-place processing, the target data buffer must not be smaller
     * than packed raw data.
     */
    static_assert(2 * sizeof(DATA_TYPE) >= 3,
                  "DATA_TYPE smaller than packed raw data is not supported.");

    /** \brief This is a short cut for the type of the source data reader. */
    using RawReader_t = typename HW::IReadPort<HW::Packed_Raw_Data_t>;

    /** \brief The callback type that is used to notify about new data. */
    using Data_Ready_Callback_t = typename HW::IReadPort<DATA_TYPE>::Data_Ready_Callback_t;

    /**
     * \brief The constructor initializes the data converter instance and binds
     *        it to the specified source reader.
     *
     * \param [in] source  The source reader instance that delivers the packed
     *                     raw data to be converted.
     */
    explicit DataConverter(RawReader_t& source);

    /**
     * \brief The destructor destroys the data converter and stops data readout
     *        from the source reader.
     */
    ~DataConverter();

    // Implementation of \ref Infineon::Avian::HW::IReadPort::start_reader
    void start_reader(HW::Spi_Command_t burst_command, size_t burst_size,
                      Data_Ready_Callback_t callback) override;

    // Implementation of \ref Infineon::Avian::HW::IReadPort::stop_reader
    void stop_reader() override;

    // Implementation of \ref Infineon::Avian::HW::IReadPort::set_buffer
    void set_buffer(DATA_TYPE* buffer) override;

private:
    /** Packed raw data to be converted is read from this IReadPort instance. */
    RawReader_t& m_source;

    /** This is the buffer, that is currently used for data reading. */
    DATA_TYPE* m_buffer;

    /** Raw data is temporarily stored in the application's buffer at this offset. */
    size_t m_raw_offset;
};

// ---------------------------------------------------------------------------- DataConverter::DataConverter
template <typename DATA_TYPE>
DataConverter<DATA_TYPE>::DataConverter(RawReader_t& source) :
    m_source(source),
    m_buffer(nullptr),
    m_raw_offset(0)
{}

// ---------------------------------------------------------------------------- DataConverter::~DataConverter
template <typename DATA_TYPE>
DataConverter<DATA_TYPE>::~DataConverter()
{
    try
    {
        m_source.stop_reader();
    }
    catch (...)
    {}
}

// ---------------------------------------------------------------------------- DataConverter::start_reader
template <typename DATA_TYPE>
void DataConverter<DATA_TYPE>::start_reader(HW::Spi_Command_t burst_command,
                                            size_t burst_size,
                                            Data_Ready_Callback_t callback)
{
    /*
     * Data conversion is processed in-place. The packed raw data is always
     * placed at the end of the application's buffer, so the conversion loop
     * can process the values in the buffer in ascending order without
     * overwriting values, that haven't been converted yet.
     * The required offset to store the raw data depends only on the burst
     * size, so it can be calculated upfront here.
     * The offset is different of target data size and packed data size.
     * (See documentation of HW::Packed_Raw_Data_t about packed data format.)
     */
    m_raw_offset = burst_size * sizeof(DATA_TYPE)
                   - burst_size * 3 / 2;

    /*
     * The core work of this class is done in the data ready callback that is
     * invoked by the source reader instance. It converts the packed raw data
     * that has just been read and afterwards calls the data ready callback
     * that has been set by the application.
     * By using data type uint16_t unpacking is done in integer domain, even
     * if target format is floating point.
     */
    auto wrapper_callback = [this, burst_size, callback](HW::Spi_Response_t burst_cmd_response) {
        auto read_ptr = reinterpret_cast<HW::Packed_Raw_Data_t*>(m_buffer) + m_raw_offset;
        DATA_TYPE* write_ptr = m_buffer;

        for (size_t i = 0; i < burst_size; i += 2)
        {
            *write_ptr++ = DATA_TYPE((uint16_t(read_ptr[0]) << 4) | (uint16_t(read_ptr[1]) >> 4));
            *write_ptr++ = DATA_TYPE((uint16_t(read_ptr[1] & 0x0F) << 8) | uint16_t(read_ptr[2]));
            read_ptr += 3;
        }

        callback(burst_cmd_response);
    };
    m_source.start_reader(burst_command, burst_size, wrapper_callback);
}

// ---------------------------------------------------------------------------- DataConverter::stop_reader
template <typename DATA_TYPE>
void DataConverter<DATA_TYPE>::stop_reader()
{
    m_source.stop_reader();
}

// ---------------------------------------------------------------------------- DataConverter::set_buffer
template <typename DATA_TYPE>
void DataConverter<DATA_TYPE>::set_buffer(DATA_TYPE* buffer)
{
    /*
     * The buffer address is remembered for the data ready callback, that will
     * convert the values in that buffer.
     */
    m_buffer = buffer;

    /*
     * Now the buffer is passed to the source reader, so raw data will be
     * stored there. See also documentation of start_reader.
     */
    auto raw_buffer = reinterpret_cast<HW::Packed_Raw_Data_t*>(m_buffer)
                      + m_raw_offset;
    m_source.set_buffer(raw_buffer);
}

/* ------------------------------------------------------------------------ */
}  // namespace Avian
}  // namespace Infineon

#endif /* IFX_AVIAN_DATACONVERTER_H */

       /* --- End of File -------------------------------------------------------- */
